---
title: "Victor's GC3 Work"
format: html
---

```{r}
library(geoR)
library(dplyr)
library(conflicted)
library(here)
library(tidyverse)
library(scico)
library(sf)
library(rnaturalearth)
library(geoR)
library(spBayes)
library(coda)
library(ggspatial)
library(dplyr)

conflicts_prefer(dplyr::filter, dplyr::select)

df <- read.csv("../data/model_data.csv")
```

There is exactly one record for each pair of `AcousticSite` and `Year`.
```{r}
df %>%
    count(AcousticSite, Year, name = "num_recs") %>%
    filter(num_recs > 1)
```

One idea was to use, at each site, records for different years as replicates. Starting values for the covariance function parameters could then be computed using sample correlations between sites. The output below shows that this approach isn't viable. At most sites, there is a record for just one year, and no site has more than three years' worth of data.
```{r}
df %>%
    group_by(AcousticSite) %>%
    summarize(num_years = n_distinct(Year)) %>%
    count(num_years, name = "num_sites")
```

For each site, for each species, sum detections across years.
```{r}
df2 <- df %>%
    select(!c(ALL, num_detectable_species)) %>%
    group_by(AcousticSite) %>%
    summarize(
        across(c(ends_with("_count"), num_nights), sum),
        Lat = Lat[1],
        Long = Long[1],
        dist_to_water = dist_to_water[1],
        water_size = water_size[1]
    ) %>%
    pivot_longer(
        ends_with("_count"), names_to = "Species", values_to = "count"
    ) %>%
    mutate(Species = str_remove(Species, fixed("_count")))
```

A few species have at least 100 observations.
```{r}
(
    species_obs_counts <- df2 %>%
        filter(count > 0) %>%
        count(Species, sort = TRUE, name = "num_obs")
)
```

For each species with at least 100 observations, the count distribution is strongly right-skewed. Some of the counts are very large, like the largest counts for `MYOLUC`. This makes me wary of fitting a spatial Poisson model. The only permissible values of the `family` argument of `spGLM()` are `"binomial"` and `"poisson"` - there's no `"quasipoisson"` option like there is for `glm()`. So, it doesn't seem to be possible to fit a spatial Poisson model with overdispersion using `spGLM()`.
```{r}
df2 %>%
    filter(Species %in% filter(species_obs_counts, num_obs >= 100)$Species) %>%
    ggplot(aes(count)) +
    facet_wrap(vars(Species), scales = "free_x") +
    geom_histogram(bins = 20) +
    theme_bw()
```

Based on the histograms below, I wonder if using `Lat` and `dist_to_water` as the coordinates is non-ideal given that for each coordinate, there is a concentration around one particular value (`45` in the case of `Lat` and `0` in the case of `dist_to_water`). If most sites have roughly the same coordinates, then most values in the spatial random effects covariance matrix are going to be roughly the same. Does this imply that the covariance matrix is close to singular?
```{r}
df2 %>%
    distinct(Lat, Long, dist_to_water) %>%
    pivot_longer(everything(), names_to = "coord", values_to = "val") %>%
    ggplot(aes(val)) +
    facet_wrap(vars(coord), scales = "free_x") +
    geom_histogram(bins = 20) +
    theme_bw()
```

Count detections by species.
```{r}
df2 %>%
    group_by(Species) %>%
    summarize(count = sum(count)) %>%
    arrange(desc(count))
```

For now, just try to fit a model using the species with the most detections. Also, put the coordinates and predictors on the same scale.
```{r}
model_df <- df2 %>%
    filter(Species == "MYOLUC") %>%
    mutate(
        Lat = as.vector(scale(Lat)),
        Long = as.vector(scale(Long)),
        dist_to_water = as.vector(scale(dist_to_water)),
        water_size = as.vector(scale(water_size))
    )
```

The sites aren't on a grid.
```{r}
model_df %>%
    ggplot(aes(dist_to_water, Lat)) +
    geom_point(alpha = 0.3) +
    theme_bw()
```

First fit a non-spatial Poisson model to the counts.
```{r}
poisson_mod <- glm(
    count ~ Long + water_size,
    poisson,
    model_df,
    offset = log(model_df$num_nights)
)
poisson_mod_coefs <- coef(poisson_mod)
poisson_mod_resid_var <- var(resid(poisson_mod))
poisson_mod_fitted_vals <- unname(fitted(poisson_mod))
```

```{r}
poisson_mod_lin_preds <- model_df %>%
    select(Long, water_size) %>%
    as.matrix() %>%
    cbind(1, .) %>%
    `%*%`(poisson_mod_coefs) %>%
    drop()
```

```{r}
near(
    poisson_mod_fitted_vals, model_df$num_nights * exp(poisson_mod_lin_preds)
) %>%
    all()
```


```{r}
spatial_rand_eff_hats <- log(model_df$count / poisson_mod_fitted_vals)
```

```{r}
# model_df_sites <- model_df %>%
#     select(AcousticSite, Lat, dist_to_water) %>%
#     unique()
```

```{r}
# model_df_dists <- model_df_sites %>%
#     `rownames<-`(.$AcousticSite) %>%
#     select(!AcousticSite) %>%
#     dist()
```

```{r}
# model_df_dists %>%
#     as.matrix() %>%
#     as_tibble(rownames = "AcousticSite1") %>%
#     pivot_longer(!AcousticSite1, names_to = "AcousticSite2", values_to = "dist")
```

This is excruciatingly slow, and the acceptance rate is 0\%.
```{r}
spatial_poisson_mod <- spGLM(
    count ~ Long + water_size,
    family = "poisson",
    weights = model_df$num_nights,
    data = model_df,
    coords = as.matrix(model_df[, c("Lat", "dist_to_water")]),
    starting = list(
        beta = poisson_mod_coefs,
        sigma.sq = poisson_mod_resid_var,
        phi = 0.5,
        w = spatial_rand_eff_hats
    ),
    # tuning = list(
    #     beta = abs(poisson_mod_coefs),
    #     sigma.sq = poisson_mod_resid_var,
    #     phi = 0.1,
    #     w = 0
    # ),
    priors = list(
        sigma.sq.ig = c(poisson_mod_resid_var, 3 * poisson_mod_resid_var),
        phi.unif = c(0.1, 1),
        beta.normal = list(poisson_mod_coefs, sqrt(diag(vcov(poisson_mod))))
    ),
    cov.model = "exponential",
    amcmc = list(n.batch = 500, batch.length = 50, accept.rate = 0.25),
    verbose = TRUE,
    n.report = 10
)
```
